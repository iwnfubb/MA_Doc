	\chapter{Grundlagen}\label{chp:Grundlageb}
In diesem Kapitel werden die theoretischen Grundlagen die in dieser Masterarbeit eingesetzt werden beschrieben. Zu Beginn wird ein detaillierter Überblick über das Hintergrundsubtraktionsverfahren gegeben. Anschließend wird die Histogrammanalyse zur Erkennung der Körperhaltung im Detail erläutert. Im Abschnitt \ref{sec:fuzzylogik} wird auf die Fuzzylogik eingegangen und wie diese einzusetzen ist. Im Weiteren wird das OpenCV Framework - eine Bibliothek von Algortihmen zur Bildverarbeitung - beschrieben. Zuletzt wird auf die Smart Home Innenkamera eingegangen, die in dieser Arbeit verwendet wurde.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hintergrundsubtraktion}\label{sec:grunglagen_hintergrundsub}
Das Hintergrundsubtraktionsverfahren ist eine häufig verwendete Technik, um sich bewegenden Objekte vor einem Hintergrund zu extrahieren. Die Hintergrundsubtraktion erzeugt ein Binärbild, das die Pixel enthält, die zu den bewegten Objekten in der Szene gehören. Wie der Name andeutet, wird die Vordergrundmaske durch die Hintergrundsubtraktion berechnet, was eine absolute Subtraktion zwischen dem aktuellen Bild und einem Hintergrundmodell darstellt. Die Abbildung \ref{fig:BS_Example} stellt ein einfaches Beispiel für die Hintergrundsubtraktion dar. Das Ergebnis einer absoluten Subtraktion von dem aktuellen Bild und einem Hintergrundmodell ist ein Binärbild, indem die Bewegung einer Person mit weißen Pixel dargestellt wird.\\
In der Arbeit \cite{benezeth2010comparative} wird eine vergleichende Studie verschiedener Hintergrundsubtraktionsverfahren nach dem Stand der Technik präsentiert. Viele Algorithmen wurden entworfen, um die Vordergrundobjekte vom Hintergrund einer Sequenz zu segmentieren und nutzen im Allgemeinen das gleiche Prinzip wie bei \cite{sobral2014comprehensive}:
\begin{itemize}
	\item \textbf{Initialisierung des Hintergrundes}: Das Hintergrundmodell wird zuerst nach einer festen Anzahl von Bildern aufgebaut. Es gibt verschiedene Methoden, wie dieses Modell aufgebaut werden kann z.B.: statistisch, Fuzzy.. .
	\item \textbf{Erkennung des Vordergrundes}: Vom neu aufgenommenen Bild wird das Hintergrundmodell absolut subtrahiert. Diese Subtraktion führt zur Berechnung des Vordergrundes der Szene, wodurch ein Binärbild entsteht. Weiße Pixel im Binärbild definieren den Vordergrund der Szene und schwarze Pixel den Hintergrund.
	\item \textbf{Aktualisierung des Hintergrundmodells}: Während dieses Aktualisierungsprozesses werden auch Bilder analysiert, um das Hintergrundmodell regelmäßig zu aktualisieren. Die Pixel, die sich längere Zeit nicht geändert haben, sollte Hintergrundpixel sein. Hier wird eine Art von Historie verwaltet. Aktualisierungen löschen nicht zwingend die vorhanden Bildern des Hintergrundmodells. Es werden neue Bilder hinzugefügt. Die Historie hat eine definierte maximal Größe. Die am ältesten vorhanden Bilder des Hintergrundmodells werden gelöscht, wenn die maximal Größe der Historie erreicht wurde, um Platz für Aktualisierungen zu schaffen.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{fig/BS_Example.pdf}
	\caption{Ein Beispiel für die Hintergrundsubtraktion. }
	\label{fig:BS_Example}
\end{figure}
Im nächsten Teil werden die Techniken beschrieben, die überlicherweise  eingesetzt werden um eine Hintergrundsubtraktion durchzuführen.
\subsection{Adaptive Gaussian Mixture Model (AGMM)}
Die wissenschaftliche Arbeit \cite{kaewtrakulpong2002improved} entwickelte ein Hintergrundmodell auf Grundlage der Gaußschen Mischung. Diese Methode ist ein gängiges Verfahren zur Hintergrundsubtraktion. Es verwendet eine selektive Aktualisierungsmethode, um jedes Hintergrundpixel durch eine Mischung von K-Gaußschen Verteilungen (üblicherweise für K = 3 oder K = 5) zu modellieren \cite{kaewtrakulpong2002improved}. Verschiedene Gauß-Mischungen stellen die verschiedenen Farben dar. Die Gewichte der Gauß-Mischung repräsentieren die Zeitanteile einer Farbe in der Szene. Die Pixel, die länger unverändert bleiben, sind die wahrscheinlichen Hintergrundfarben. Für jedes neue Pixel wird anhand der bekannten Modellkomponenten überprüft, ob der Pixelwert eine Hintergrundfarbe darstellt. Das Hintergrundmodell wird dann aktualisiert, wenn das Pixel in eine der K-Gaußschen-Komponenten passt. Aktualisierst wird nur die Erste passende K-Gaußsche-Komponente.  Wenn keine passende K-Gaußschen-Komponenten gefunden werden, wird eine neue Komponente mit dem Pixelwert als Mittelwert gesetzt, eine große Kovarianz-Matrix und ein kleines Gewicht $w_k$ hinzugefügt. \\
Jedes Pixel in der Szene wird durch eine Mischung von K-Gaußschen Verteilungen modelliert. Die Wahrscheinlichkeit, dass ein bestimmtes Pixel zum Zeitpunkt $n$ einen Wert von $\mathrm{x}_{n}$ hat, kann wie folgt beschrieben werden\cite{kaewtrakulpong2002improved}:\\
\begin{equation}
p(\mathrm{x}_{n}) = \sum \limits_{j=1}^K w_j \eta(x;\mu_k, \Sigma_k)
\end{equation}
wobei $w_j$ der Gewichtsparameter der k-ten Gauß-Komponente ist. Außerdem ist $\eta(x;\mu_k, \Sigma_k)$ die Normalverteilung der k-ten Komponente, die wie folgt dargestellt wird \cite{kaewtrakulpong2002improved}:\\
\begin{equation}
\eta(x;\mu_k, \Sigma_k) = \frac{1}{(2\pi)^\frac{D}{2} |\Sigma_k|^\frac{1}{2}} \mathrm{e}^{-\frac{1}{2}(x-\mu_k)^T \Sigma_k^{-1}(x-\mu_k)}
\end{equation}
wobei $\mu_k$ der Mittelwert ist. Außerdem ist $\Sigma_k =  \sigma^2_k I$ die Kovarianz der k-ten Komponente \cite{kaewtrakulpong2002improved}. Die K-Verteilungen sind auf der Grundlage des Fitnesswerts $\frac{w_k}{\sigma_k}$ geordnet und die ersten $B$-Verteilungen werden als ein Modell des Hintergrundes der Szene verwendet, wo $B$ wie folgt beschrieben wird\cite{kaewtrakulpong2002improved}:\\
\begin{equation}
B = \underset{b}{\arg\min}(\sum \limits_{j=1}^b w_j > T) 
\end{equation}
Der Schwellenwert $T$ ist der Mindestanteil des Hintergrundmodells und stellt die kleinste Wahrscheinlichkeit dar, dass der Hintergrund in der Szene bleibt. Die Hintergrundsubtraktion in \cite{kaewtrakulpong2002improved} wird durchgeführt, indem die Vordergrundpixel die Pixel sind, die in einer der B-Verteilungen eine Standardabweichung von mehr als $2,5$ aufweisen. Diese Pixel werden weiß gefärbt. Die erste Gaußschen-Komponente, die die Bedingung 2.3 erfüllt, wird durch die folgenden Aktualisierungsgleichungen aktualisiert \cite{kaewtrakulpong2002improved}:
\begin{eqnarray}
\hat{w}^{N+1}_k &=& (1-\alpha) \hat{w}^{N}_k + \alpha \hat{p} (\Theta_k | \mathrm{x}_{N+1}) \\
\hat{\mu}^{N+1}_k &=& (1-\alpha) \hat{\mu}^N_k + \rho\mathrm{x}_{N+1} \\
\hat{\Sigma}^{N+1}_k &=& (1-\alpha)\hat{\Sigma}^N_k + \rho(\mathrm{x}_{N+1} - \hat{\mu}^{N+1}_k)(\mathrm{x}_{N+1} - \hat{\mu}^{N+1}_k)^T\\
\rho &=& \alpha\eta(\mathrm{x}_{N+1};\hat{\mu}^N_k; \hat{\Sigma}^N_k)\\
 \hat{p} (\Theta_k | x_{N+1})&=&\left\{\begin{array}{@{}ll@{}}
0, & \text{wenn}\ \Theta_k\ \text{erste passende Gauß-Komponente ist} \\
1, & \text{sonst}
\end{array}\right.
\end{eqnarray}
wobei $\Theta_k$ die k-te Gaußschen Komponente ist und $\frac{1}{\alpha}$ definiert die Zeitkonstante, die die Änderung bestimmt. Der aktualisierte Gewichtsparameter wird mit $\hat{w}^{N+1}_k$ genannt und $\hat{\mu}^{N+1}_k$, $\hat{\Sigma}^{N+1}_k$ sind erneute Mittelwert und Kovarianz.
Wenn keine der K-Verteilungen mit diesem Pixelwert zusammenpasst, wird die unwahrscheinliche Komponente durch eine Verteilung mit dem aktuellen Wert als Mittelwert, einer großen Kovarianz-Matrix und einem kleinen Gewicht ersetzt \cite{kaewtrakulpong2002improved}.
\subsection{Kernel Density Estimation (KDE)}
Ein Nachteil von \acs{AGMM} ist: Dieses Modell kann keine empfindliche Detektion erreichen, wenn der Hintergrund sehr hohe Frequenzvariation aufweist. Dieser Nachteil kann mit einem \acs{KDE} Modell, das in \cite{elgammal2000non} beschrieben wurde, gelöst werden.\\
Sei $x_1, x_2,..., x_n$ eine aktuelle Stichprobe von Intensitätswerten für ein Pixel. Unter Verwendung dieser Stichprobe kann die Dichtefunktion der Wahrscheinlichkeit, dass dieses Pixel einen Intensitätswert $x_t$ in Zeit $t$ hat, unter Verwendung des Kernschätzers $K$ mit Brandbreite $D$ als nicht-parametrisch geschätzt werden \cite{elgammal2000non}.
\begin{equation}
P(x_t) = \frac{1}{n} \sum \limits_{i=1}^n K_D (x_t - x_i) 
\end{equation}
Angenommen ist $D$ die Kernel-Funktionsbandbreite und verschiedene Farbkanäle werden mit unterschiedlichen Kernel-Bandbreiten $\sigma^2_j$ für den j-ten Farbkanal wie die Gleichung 2.10 dargestellt.

\begin{gather}
D
=
\begin{pmatrix}
\sigma^2_1 & 0 & 0 \\
0 & \sigma^2_2 & 0 \\
0 & 0 & \sigma^2_3 \\
\end{pmatrix}
\end{gather}
Wenn die Kernel-Schätzfunktion $K$ als Normalfunktion $N (0;\sigma)$ gewählt wird, wird die Dichtefunktion dann wie folgt beschrieben:
\begin{equation}
P(x_t) = \frac{1}{n} \sum \limits_{i=1}^N \prod \limits_{j=1}^d \frac{1}{\sqrt{2\pi\sigma^2_j}} \mathrm{e} ^ {-\frac{1}{2} \frac{({x_t}_j - {x_i}_j)^2}{\sigma^2_j}}
\end{equation}
Bei  $P(x_t)<T$ wird das Pixel als ein Vordergrundpixel betrachtet. In diesem Fall ist $T$ ein globaler Schwellenwert über das gesamte Bild. $T$ kann so eingestellt werden, dass nur ein minimaler Prozentsatz von fehlerhaften Erkennungen erreicht wird.\\
Angenommen ist $m$ Median von $|x_i - x_{i+1}|$ für jedes Paar $(x_i, x_{i+1})$ in der Stichprobe. Nach \cite{elgammal2000non} wird die Standardabweichung der ersten Verteilung wie folgt geschätzt: 
\begin{equation}
D = \frac{m}{0,68 \sqrt{2}}
\end{equation}
Bei \acs{KDE} gibt es zwei Alternativen für die Aktualisierung des Hintergrundes: \glqq{}Selective Update\grqq{} und \glqq{}Blind Update\grqq{}. Die erste Alternative fügt neue Stichproben zum Modell hinzu, wenn sie als Hintergrund klassifiziert sind. Die zweite Alternative fügt einfach neue Stichproben zum Modell hinzu, egal ob sie zum Hintergrund oder Vordergrund gehören. Im Allgemeinen funktioniert \acs{KDE} draußen besser als die \acs{GMM} Methode.

\subsection{K-nächster Nachbar (KNN)}
Diese Methode ist eine Verbesserung der \acs{KDE} Methode und wird in \cite{zivkovic2006efficient} als K-NN bezeichnet. Bei dieser Methode wird  die feste Kerngröße $D$ in \acs{KDE} für jeden neuen Punkt $x_i$ angepasst. Anstatt der Optimierungen der Kerngröße $D$, erhöht diese Methode die Kerngrößen $D$, solang eine feste Menge von Daten $k$ abgedeckt ist. 
Mit der K-NN-Methode befinden sich große Kerne in den Gebieten mit einer kleinen Anzahl von Stichproben und kleinere Kerne in den dicht besiedelten Gebieten. In ~\cite{zivkovic2006efficient} wird $k = [0.1n]$ gewählt, wobei $n$ die Zeit für die Anpassung des Modells ist und $[n]$ für das Aufrunden einer realen Zahl $n$ auf die nächste natürliche Zahl steht. Ein neues Pixel $x_i$ passt zum Modell, wenn mehr als $k$ Punkte innerhalb von $n$ Kernen vorhanden sind. Aus diesem Grund wird der $k$-te Nachbar als Schwellenwert für diese Verbesserung verwendet. 

\subsection{Vibe}
In \cite{barnich2009vibe} wird ein Verfahren beschrieben, welches eine zufällige Aggregation der Hintergrundsubtraktion verwendet. Das Verfahren wird \glqq{}ViBe\grqq{} genannt. Sei $p_t(x)$ ein Pixelwert $x$ zur Zeit $t$. Beim \acs{GMM}- oder \acs{KDE}-Modell wird ein Pixelwert $p_t(x)$ als Hinter- oder Vordergrund klassifiziert, abhängig davon, wie des Pixel mit der Dichtefunktion des Modells passt. In \glqq{}ViBe\grqq{} wird eine Menge von Stichprobenwerten als Pixelmodell verwendet. Um einen Wert $p_t(x)$ zu klassifizieren, wird der Wert mit seinen nächstliegenden Werten in der Menge der Stichproben verglichen, indem eine Kugel $S_R(p_t(x))$ mit Radius $R$ und Punkt $p_t(x)$ definiert wird. Ein Pixel ist genau dann als Hintergrund klassifiziert, wenn die Überschneidung $\sharp$ von der Kugel $S_R(p_t(x))$ und die Menge von Punkten ${p_1, p_2, ..., p_n}$ mehr als der Schwellenwert $\sharp_{min}$ ist (siehe Abbildung ~\ref{fig:vibe}).
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{fig/vibe.pdf}
	\caption{Die Klassifizierung von $p_t(x)$ basiert auf die Überschneidung der Kugel $S_R(p_t(x))$ mit der Menge der Stichproben \cite{barnich2009vibe}.}
	\label{fig:vibe}
\end{figure}
Im nächsten Kapitel wird ein Vergleich der vier oben genannten Verfahren und meine eigene Methode beschrieben. Es wird auch auf die verschiedenen Vor- und Nachteile eingegangen.
\section{Histogrammanalyse}\label{sec:Histogrammanalyse}
Ein Histogramm eines Bilds stellt die Tonwertverteilung in einem digitalen Bild graphisch dar. Ein Bildhistogramm zeichnet die Anzahl der Pixel für jeden Tonwert auf. Es bietet ein nützliches Werkzeug für die $Schwellwertbildung$ auf dem Gebiet der Computervision an. Die graphische Darstellung von Histogrammen enthält Informationen über die Pixelverteilung als eine Funktion der Tonvariation, deswegen lassen sich Bild-Histogramme auf Hoch- und Tiefpunkte analysieren \cite{suttonhistograms}.\\ 
Jede Körperhaltung erzeugt ein unterschiedliches Muster von Histogrammen, deswegen kann das Projektions-Histogramm als eins der Eigenschaften verwendet werden, um unterschiedliche Körperhaltung zu unterscheiden. Nach der Hintergrundsubtraktion wird eine Silhouette des Vordergrundes als Binärbild erstellt. Eine Körperhaltungsanalyse wird auf die Silhouette angewendet, um die Ähnlichkeiten der horizontalen und vertikalen Projektions-Histogramme der erkannten Silhouette und der Haupthaltungen (Stehen, Beugen, Liegen und Sitzen) zu berechnen. Die Normalisierung des durchschnittlichen Histogramms erfolgt durch die Skalierung auf 128 Pixel der Silhouette indem sowohl Höhe und Breite skaliert werden, bis beide Größen kleiner oder gleich 128 Pixel aufweisen. Dabei wird das ursprünglichen Seitenverhältnis nicht verändert. \cite{haritaoglu1998ghost}. Normalisierte horizontale und vertikale Referenz-Histogramme für jede Körperhalterung wurden experimentell unter Verwendung von $4500$ Silhouetten von $7$ verschiedenen Personen berechnet \cite{haritaoglu1998ghost} (siehe Abbildung ~\ref{fig:histogramm}).   
\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{fig/histogramm.pdf}
	\caption{Normalisierte horizontale und vertikale Referenz-Histogramme für jede Körperhaltung \cite{haritaoglu1998ghost}.}
	\label{fig:histogramm}
\end{figure}
Die durch die Hintergrundsubtraktion erstellte Silhouette wird mit den durchschnittlichen Projektions-Histogrammen verglichen, wobei die Summe der absoluten Differenzen verwendet wird, um die ähnlichste Körperhaltung zu ermitteln. Angenommen $S_i$ ist die Ähnlichkeit zwischen der erkannten Silhouette und der i-ten Körperhaltung. Seien $H_i$ und $V_i$ die horizontalen und vertikalen durchschnittlichen Projektions-Histogramme. $P$ und $R$ sind die horizontalen und vertikalen Histogramme der erkannten Silhouette. $S_i$ wird dann wie folgt berechnet: 
\begin{equation}\label{eq:loglikelyhood}
S_i = -\log(\sum \limits_{h}^{128} \sum \limits_{v}^{128} |H_h^i - P_h| + |V_v^i - R_v|) 
\end{equation}
Die Körperhaltung, die das höchste Ähnlichkeitsmaß ergibt, wird als die wahrscheinlichste Haltung angenommen.
\section{Fuzzylogik}\label{sec:fuzzylogik}
Unter Verwendung der Hintergrundsubtraktion zusammen mit einer Histogrammanalyse kann eine bewegte Person erkannt bzw. auch ihre Körperhaltung ermittelt werden. . Um aus diesen gewonnenen Informationen eine außergewöhnliche Situationen zu erkennen, kommt die Fuzzylogik zum Einsatz. Im Jahre 1971  wurden die ersten Arbeiten über die sogenannte Fuzzy-Algebra veröffentlicht\cite{rosenfeld1971fuzzy}.\\
Es gibt mehre Gründe für den Einsatz der Fuzzylogik. Einer der Gründe ist, dass die mathematischen Konzepte hinter der Fuzzylogik einen geringen Grad an Komplexität haben.\\
Bei der Fuzzylogik geht es um viele frei wählbare Mengen, die jeweils einen Eingabeparameter abbilden. Die Mengen werden unter der gewählten Fuzzylogik definierten Regeln gerechnet. Durch die verschiedenen Kombinationen entstehen neue Mengen, die Fuzzymengen genannt werden.
Bei einer Kombination heißt der Anteil des neuen Werts in einer Fuzzymenge, Mitgliedschaft-Grad. Der Mitgliedschaft-Grad beschreibt den Anteil des Eingabeparameters in einer Fuzzymenge.
Objekte bekommen den Wert $1$ zugewiesen, wenn sie vollständig innerhalb der Fuzzymenge liegen. Objekten außerhalb der Fuzzymenge bekommen den Wert $0$ zugewiesen. Jedes Objekt, das teilweise in der Menge ist, bekommt einen Wert aus dem offenen Intervall $(0, 1)$ zugewiesen. Der Prozess der Fuzzylogik wird wie folgt definiert ~\cite{dingle2011artificial}:
\begin{itemize}
\item Zuerst wird eine scharfe Menge von Eingabedaten gesammelt und unter Verwendung von Zugehörigkeit-Funktionen in Fuzzymengen umgewandelt. In diesem Schritt wird ein Zuordnung zwischen jedem scharfen Wert der Eingaben und der Fuzzy-Menge wie folgt erstellt \cite{cingolanijfuzzylogic}:\\
$A' = F(x_0)$\\
wobei $x_0$ ein scharfer Wert der Eingabe ist. $A'$ ist die Fuzzymenge der Mitgliederfunktion $F$. $F$ kann eine beliebige stetig Funktion wie z.B.: Eine Sinus-, Kosinus-, Sigmoid-, Gaußschen-Funktion sein. 
\item  Eine Schlussfolgerung wird basierend auf einer oder mehreren ($IF-THEN$) Regeln getroffen und die Regeln werden wie folgt beschrieben:\\
\textit{If X is A then Y is B}\\
\textit{Und wenn X A' ist, ergibt sich Y ist B'}\\
Wobei $X$ und $Y$ linguistische Variablen (Siehe Algorithmus \ref{algo:fuzzy}) sind. $A$ und $B$ sind Fuzzymengen, $B'$ ist die Ausgabe der Fuzzymenge. In diesem Schritt erhält das Fuzzysystem zunächst den Übereinstimmungsgrad jeder Regel durch Anwendung eines konjunktiven Operators (AND- oder OR-Operator). Danach werden die Fuzzy-Sätze durch einen Fuzzy-Implikationsoperator (normalerweise Minimum oder Produkt) abgeleitet. Eine gleiche Anzahl von Ausgabesätzen wie in den vordefinierten Regeln, werden an dieser Stelle erzeugt. Am Ende werden diese Gruppen von Ausgaben durch einen Aggregationsoperator (Maximum, Summe, normalisierte Summe, OR-Wahrscheinlichkeit) aggregiert. 
\item  Schließlich wird die Fuzzy-Ausgabe unter Verwendung der Zugehörigkeitsfunktionen in dem Defuzzifizierungsschritt auf eine scharfe Ausgabe abgebildet. Ein Wert für jede Variable wird mithilfe der ausgewählten Defuzzifizierungsmethode berechnet, die wie folgt definiert werden kann \cite{dingle2011artificial}:\\
\begin{itemize}
	\item Schwerpunkt: $\frac{\int x \mu (x) dx}{\int \mu (x) dx}$\\.
	\item Schwerpunkt Singleton: $\frac{\sum_{i}x_i\mu_i}{\sum_{i}\mu_i}$\\
	\item Zentrum der Region: $u|\int_{u}^{\infty} \mu(x) dx$\\
	\item Rightmost Maximum: $argmax_x [\mu (x) = max (\mu(x))]$\\
	\item Leftmost Maximum: $argmin_x [\mu (x) = max (\mu(x))]$\\
	\item Durchschnittliches Maximum: $mean(x) [\mu (x) = max (\mu(x))]$\\
\end{itemize}
\end{itemize}
Die Abbildung \ref{fig:Fuzzy_Example} stellt diese drei Schritte der Fuzzylogik in graphischen Bildern dar. Als Beispiel wird ein Thermostat genommen, dessen Ventilöffnung entsprechend der Raumtemperatur gesteuert wird. Die hierzu erstellte Fuzzylogik bekommt die Temperatur als Eingabe und den Öffnungsgrad des Ventils als Ausgabe (siehe Abbildung \ref{fig:Fuzzy_Example}). Der Regel-Algorithmus wird wie in Algorithmus \ref{algo:fuzzy} definiert. Die Temperatur wird als \glqq{}Low, Medium und High\grqq{} klassifiziert. Wenn die Temperatur zwischen $0°$ und $20°$ ist, wird sie als \glqq{}Low\grqq{} klassifiziert. Werte zwischen $10°$ und $20°$ werden als \glqq{}Medium\grqq{} klassifiziert. Der Bereich von $20°$ bis $40°$ wird der Klassifizierung \glqq{}High\grqq{} zugeordnet. Als Öffnungsgrad des Thermotatventils wird das geschlossene Intervall $[1, 2]$ als \glqq{}Low\grqq{}, das Intervall $[1, 4]$ als \glqq{}Medium\grqq{} und letztlich das Intervall $[3, 5]$ als \glqq{}High\grqq{} klassifiziert. Eine Beispieleingabe der Temperatur von $23°$, die sich zwischen \glqq{}Medium\grqq{} und \glqq{}High\grqq{} befindet, ist in Abbildung \ref{fig:Fuzzy_Example} zu sehen. Bei $23°$ beträgt der Mitgliedschaftsgrad $0.7$ zur Menge \glqq{}Medium\grqq{} und $0.3$ zu \glqq{}High\grqq{}. Nach der Regel in Algorithmus \ref{algo:fuzzy}, wird der Öffnungsgrad des Thermotatventils zwischen \glqq{}Low\grqq{} und \glqq{}Medium\grqq{} berechnet und mit der Methode \glqq{}Schwerpunkt\grqq{} liegt der Öffnungsgrad des Thermotatventils bei $2.15$.\\
\begin{figure}[H]
	\centering
	\includegraphics[width=0.59\textwidth]{fig/fuzzy.pdf}
	\caption{Ein Beispiel für die Fuzzylogik in drei Schritten. Oben: Die Temperatur von $23$ Grad wird durch Mitgliederfunktionen abgebildet. Mitte: Durch die (IF-ELSE) Regel in Algorithmus \ref{algo:fuzzy} wird eine Ausgabe als Fuzzymenge berechnet. Unten: Ein Schwerpunkt von der gerechneten Ausgabe wird in eine scharfe Ausgabe abgebildet und es ergibt sich der Wert 2.15 für das Thermostat.} 
	\label{fig:Fuzzy_Example}
\end{figure}
\begin{algorithm}[H]
\caption{Regel für Raumtemperatur und Einstellung des Thermostates.	}
\label{algo:fuzzy}
\If{temperature IS low}{thermostat IS high;}
\If{temperature IS medium}{thermostat IS medium;}
\If{temperature IS high}{thermostat IS low;}
\end{algorithm}
Die Berechnung und graphische Darstellung der Fuzzylogik in dieser Arbeit werden mit der Open-Source-Bibliothek \glqq{}jFuzzyLogic\grqq{} realisiert.
\section{OpenCV Framework}\label{sec:OpenCV}
OpenCV steht für Open-Computer-Vision. Die Bibliothek ist in C und C++ programmiert und kann auf vielen Betriebsystemen verwendet werden. OpenCV kann auch mithilfe von Java, Python, Ruby, Mathlab... verwendet werden. OpenCV wurde mit Fokus auf Recheneffizienz entwickelt, um Echtzeitanwendungen zu unterstützen. Diese Bibliothek enthält über 500 Funktionen, die viele Bereiche der Bildverarbeitung einschließlich maschinellem Lernen, neuronaler Netze, usw. umfassen\cite{bradski2008learning}. OpenCV vereinfacht den Bildverarbeitungsprozess mit vielen hilfreichen vordefinierten Funktionen. Da es sich in dieser Arbeit um ein Echtzeitanwendung handelt, wird auf OpenCV gesetzt, um die Verarbeitungszeit gering zu halten.

\section{360° Kamera}
Ziel dieser Arbeit war es, eine Echtzeitanwendung zu entwickeln die mit der Bosch Smart Home Innenkamera funktioniert. Die Testvideos in dieser Arbeit wurden mit dieser Kamera aufgenommen. Die Bosch 360° Innenkamera kann sich in jede Richtung (360°) drehen. Die Kamera verfügt über Bewegungssensoren, eine Gegensprechanlage für Zwei-Wege-Audio und Infrarot-Nachtsicht-Funktion. Sie zeichnet Bild-Material in HD-Qualität auf. Das Bild-Material kann auf PC bzw. externen Speicher kopiert werden. Die Innenkamera verfügt über verschiedene Schnittstellen wie zum Beispiel WLAN. Die Internetverbindung wird von der Kamera genutzt, um Push-Nachrichten an ein Smartphone zu schicken. Dank der integrierten Bewegungsmelder kann die Kamera einer Bewegung folgen bzw. sich automatisch drehen, um das bewegte Objekt im Bild zu halten. Dies ist in dieser Arbeit sehr hilfreich.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{fig/BoschInnenkamera.jpg}
	\caption{Bosch 360° Kamera (Quelle: www.bosch-smarthome.com) } 
	\label{fig:BoschInnenCam}
\end{figure}